<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Производительность</title>

 </head>
 <body><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="regexp.reference.recursive.html">Рекурсивные шаблоны</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="reference.pcre.pattern.modifiers.html">Описывает возможные модификаторы шаблонов Perl-совместимых регулярных выражений (PCRE)</a></div>
 <div class="up"><a href="reference.pcre.pattern.syntax.html">Описание синтаксиса Perl-совместимых регулярных выражений</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="regexp.reference.performance" class="section">
  <h2 class="title">Производительность</h2>
  <p class="para">
   Некотрые элементы, которые могут встречаться в шаблонах, являются более
   эффективными, чем ряд других. Например, гораздо эффективней использовать
   символьный класс [aeiou] вместо набора альтернатив (a|e|i|o|u).
   Как правило, более простая конструкция является более эффективной.
   Книга Джеффри Фридла содержит много обсуждений вопроса оптимизации
   регулярных выражений.
  </p>
  <p class="para">
   В случае, если шаблон начинается с .* и используется флаг <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_DOTALL</a>,
   шаблон неявно заякоривается, так как он может совпадать только
   в начале строки. Но если
   <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_DOTALL</a>
   не используется, PCRE не может выполнить соответствующую оптимизацию,
   так как в таком случае метасимвол &#039;.&#039; не соответствует символу начала
   строки (если обрабатываемые данные содержат переводы строк, такой шаблон
   может соответствовать шаблону не от начала строки, а от позиции
   непосредственно после перевода строки).
   Например, применяя шаблон

   <em>(.*) second</em>

   к строке &quot;first\nand second&quot; (где \n обозначает символ
   перевода строки), значение, захваченное первой подмаской, будет &#039;and&#039;.
   Чтобы обработать все возможные точки соответствия, PCRE пытается
   сопоставить шаблон после каждого символа перевода строки.
  </p>
  <p class="para">
   В случае, если вы используете подобные шаблоны для обработки
   данных, не содержащих переводы строк, для лучшей производительности
   используйте модификатор
   <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_DOTALL</a>,
   либо начинайте шаблон с ^.* для указания явного заякоривания.
   Это предотвратит PСRE от поиска символов новых строк и дополнительных
   попыток сопоставить шаблон с каждой такой найденной позицией.
  </p>
  <p class="para">
   Избегайте шаблонов, которые содержат вложенные неограниченные повторения.
   Сопоставление их со строками, не содержащими совпадений, занимает
   длительное время. Рассмотрим пример шаблона

   <em>(a+)*</em>
  </p>
  <p class="para">
   Он может соответствовать с  &quot;aaaa&quot; 33-мя различными способами, и эта
   цифра очень быстро растет при увеличении строки. (В данном примере,
   квантификатор * может совпадать 0, 1, 2, 3 или 4 раза,
   и для каждого такого случая, кроме нуля, квантификатор + также может
   совпадать различное число раз.) Если остаток шаблона таков, что все
   совпадение терпит неудачу, PCRE должна попробовать все возможные
   варианты совпадения, что может потребовать огромного количества времени.
  </p>
  <p class="para">
   При помощи оптимизации можно отловить наиболее простые случаи, такие как

   <em>(a+)*b</em>

   где следом идёт литеральный символ. Прежде, чем производить стандартную
   процедуру поиска, PCRE проверяет в последующей подстроке наличие
   символа &#039;b&#039;, и, в случае отсутствия такового,  попытка сопоставления
   немедленно завершается неудачей. Однако, когда последующего литерала нет,
   оптимизация не может быть применена. Вы можете ощутить разницу, сравнив поведение

   <em>(a+)*\d</em>

   с поведением приведенного выше шаблона. Первый определяет
   невозможность сопоставления практически сразу же, при сопоставлении
   со строкой состоящей из символов &#039;a&#039;, в то время как второй
   тратит длительное время на поиск в строках длинее 20 символов.
  </p>
 </div><hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="regexp.reference.recursive.html">Рекурсивные шаблоны</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="reference.pcre.pattern.modifiers.html">Описывает возможные модификаторы шаблонов Perl-совместимых регулярных выражений (PCRE)</a></div>
 <div class="up"><a href="reference.pcre.pattern.syntax.html">Описание синтаксиса Perl-совместимых регулярных выражений</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
