<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Сбор циклических ссылок</title>

 </head>
 <body><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="features.gc.refcounting-basics.html">Основы подсчета ссылок</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="features.gc.performance-considerations.html">Вопросы производительности</a></div>
 <div class="up"><a href="features.gc.html">Сборка мусора</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="features.gc.collecting-cycles" class="sect1">
   <h2 class="title">Сбор циклических ссылок</h2>
   <p class="para">
    Обычно механизмы подсчета ссылок в памяти, например, используемый в PHP ранее,
    не решают проблему утечки памяти из-за циклических ссылок.
    Начиная с версии 5.3.0, в PHP реализован синхронный механизм из исследования
    &quot;<a href="http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf" class="link external">&raquo;&nbsp;Concurrent Cycle Collection in Reference Counted Systems</a>&quot;,
    в котором рассматривается этот вопрос.
   </p>
   <p class="para">
    Полное описание работы алгоритма выходит за рамки данного раздела, поэтому
    приведены только основы. Прежде всего мы должны задать несколько основных правил.
    Если счетчик ссылок увеличивается, то контейнер все еще используется и не является мусором.
    Если счетчик уменьшается до нуля, то zval может быть удален.
    Исходя из этих правил утечки памяти с циклическими ссылками могут получиться только
    при уменьшении счетчика ссылок до ненулевого значения.
    Затем, в выделенных контейнерах можно найти мусор проверив возможность уменьшения
    всех счетчиков ссылок на единицу и определив те контейнеры, у которых счетчик станет равным нулю.
   </p>
   <p class="para">
     <div class="mediaobject">
      
      <div class="imageobject">
       <img src="images/12f37b1c6963c1c5c18f30495416a197-gc-algorithm.png" alt="Алгоритм сборки мусора" width="614" height="814" />
      </div>
     </div>
   </p>
   <p class="para">
    Для избежания постоянной проверки на мусор с циклическими ссылками при каждом уменьшении счетчика ссылок,
    алгоритм добавляет все возможные корни (zval контейнеры) в &quot;корневой буфер&quot; (помечая
    их как &quot;фиолетовые&quot;). Это также гарантирует попадание любого корня в буфер только один раз.
    Механизм сборки мусора стартует только тогда, когда наполняется буфер (см. шаг A
    на рисунке выше).
   </p>
   <p class="para">
    На шаге B алгоритм производит поиск в глубину по всем возможным корням для
    однократного уменьшения счетчика ссылок на единицу у всех контейнеров
    (помечая их как &quot;серые&quot;). На шаге C алгоритм снова производит поиск в глубину
    для проверки счетчиков ссылок. Если он находит счетчик с нулевым значением, то
    контейнер помечается как &quot;белый&quot; (на рисунке отображено синим). Если же счетчик больше нуля, то
    происходит поиск в глубину от этого контейнера с обратным увеличением счетчиков на единицу
    и повторной пометкой как &quot;черный&quot; на их контейнерах. На последнем шаге D алгоритм проходит по
    корневому буферу и удаляет из него корни контейнеров, заодно проверяя какие контейнеры
    помечены как &quot;белые&quot;. Эти контейнеры будут освобождены из памяти.
   </p>
   <p class="para">
    Теперь, когда вы имеете представление о работе алгоритма, рассмотрим его
    интеграцию в PHP. По умолчанию сборщик мусора всегда включен.
    Для изменения этой опции используется параметр
    <a href="info.configuration.html#ini.zend.enable-gc" class="link">zend.enable_gc</a> в <var class="filename">php.ini</var>.
   </p>
   <p class="para">
    Если сборщик мусора включен, алгоритм поиска циклических ссылок выполняется каждый раз,
    когда корневой буфер наполняется 10,000 корнями (вы можете поменять это значение,
    изменив константу <em>GC_ROOT_BUFFER_MAX_ENTRIES</em> в файле
    <em>Zend/zend_gc.c</em> в исходном коде PHP и пересобрав PHP).
    Если сборщик мусора выключен, алгоритм никогда не будет запущен. Тем не менее,
    буфер всегда заполняется корнями.
   </p>
   <p class="para">
    Если буфер заполнился при выключенном механизме сборки мусора, то
    другие корни не будут в него записаны. Таким образом, если они окажутся
    мусором с циклическими ссылками, то никогда не будут очищены и создадут утечку памяти.
   </p>
   <p class="para">
    Причиной постоянной записи корней в буфер даже при выключенном
    механизме сборки мусора является то, что это намного быстрее,
    чем постоянно проверять включен ли механизм сборки мусора или нет.
    Однако, сама сборка мусора и алгоритм ее анализа могут занимать значительное
    время.
   </p>
   <p class="para">
    Помимо изменения параметра <a href="info.configuration.html#ini.zend.enable-gc" class="link">zend.enable_gc</a>,
    механизм сборки мусора также можно запустить и остановить вызвав функции
    <span class="function"><a href="function.gc-enable.html" class="function">gc_enable()</a></span> и <span class="function"><a href="function.gc-disable.html" class="function">gc_disable()</a></span> соответственно.
    Вызов этих функций имеет тот же эффект, что и включение/выключение механизма с
    помощью настроек конфигурации.
    Кроме того, можно запустить сборку мусора, даже если корневой буфер еще не заполнен.
    Для этого вы можете вызвать функцию <span class="function"><a href="function.gc-collect-cycles.html" class="function">gc_collect_cycles()</a></span>, которая
    также возвращает количество циклических ссылок собранных алгоритмом.
   </p>
   <p class="para">
    Причиной включения и выключения механизма сборки, а также его ручного запуска,
    может стать то, что некоторые части вашего приложения могут быть требовательными
    ко времени. В этих случаях вы, возможно, не захотите постороннего вмешательства
    сборщика мусора. Разумеется, выключая сборщик мусора в определенных
    местах вашего приложения вы рискуете получить утечку памяти, т.к.
    потенциально некоторые корни могут не поместиться в ограниченный
    корневой буфер. Более целесообразно будет вызвать <span class="function"><a href="function.gc-collect-cycles.html" class="function">gc_collect_cycles()</a></span>
    непосредственно перед вызовом <span class="function"><a href="function.gc-disable.html" class="function">gc_disable()</a></span> для освобождения памяти и уже
    записанных корней в буфере. Это очистит буфер и позволит использовать больше места
    для хранения корней, пока механизм будет выключен.
   </p>
  </div><hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="features.gc.refcounting-basics.html">Основы подсчета ссылок</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="features.gc.performance-considerations.html">Вопросы производительности</a></div>
 <div class="up"><a href="features.gc.html">Сборка мусора</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
