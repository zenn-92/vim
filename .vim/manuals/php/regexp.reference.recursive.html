<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>Рекурсивные шаблоны</title>

 </head>
 <body><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="regexp.reference.comments.html">Комментарии</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="regexp.reference.performance.html">Производительность</a></div>
 <div class="up"><a href="reference.pcre.pattern.syntax.html">Описание синтаксиса Perl-совместимых регулярных выражений</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="regexp.reference.recursive" class="section">
  <h2 class="title">Рекурсивные шаблоны</h2>
  <p class="para">
   Рассмотрим задачу поиска соответствия со строкой, находящихся
   внутри неограниченного количества круглых скобок. Без использования
   рекурсии лучшее, что можно сделать - написать шаблон, который
   будет решать задачу для некоторой ограниченной глубины вложенности, так
   как обработать неограниченную глубину не предоставляется возможным.
   В Perl 5.6 предоставлены некоторые экспериментальные возможности,
   которые в том числе позвояляют реализовать рекурсию в шаблонах.
   Специально обозначение (?R) используется для указания рекурсивной
   подмаски. Таким образом, приведем PCRE шаблон, решающий поставленную
   задачу (подразумевается, что используется модификатор
   <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_EXTENDED</a>,
   незначащие пробелы игнорируются):

   <em>\( ( (?&gt;[^()]+) | (?R) )* \)</em>
  </p>
  <p class="para">
   Вначале он соответствует открывающей круглой скобке. Далее
   он соответствует любому количеству подстрок, каждая из которых
   может быть последовательностью не-скобок, либо строкой, рекурсивно
   соответствующей шаблону (т.е. строкой, корректно заключенной в
   круглые скобки). И, в конце, идет закрывающая круглая скобка.
  </p>
  <p class="para">
   Приведенный пример шаблона использует вложенные неограниченные повторения,
   поэтому использование однократных шаблонов значительно ускоряет процесс
   сопоставления, особенно в случаях, когда строка не соответствует заданной
   маске. Например, если его применить к строке:

   <em>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</em>,

   то несоответствие будет обнаружено достаточно быстро. Но в случае, если
   однократные шаблоны не используются, сопоставление будет затягиваться
   на длительное время, так как существует множество способов разделения
   строки между квантификаторами + и *, и все они должны быть проверены,
   прежде чем будет выдано сообщение о неудаче.
  </p>
  <p class="para">
   Значение, устанавливаемое для захватывающей подмаски будет соответствовать
   значению, захваченному на наиболее глубоком уровне рекурсии. В случае,
   если приведенный выше шаблон сопоставляется со строкой

   <em>(ab(cd)ef)</em>,

   захваченным значением будет &#039;ef&#039;, которое является последним значением,
   принимаемым на верхнем уровне. В случае, если добавить дополнительные скобки

   <em>\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</em>,
   захваченным значением будет &quot;ab(cd)ef&quot;. В случае, если
   в шаблоне встречается более, чем 15 захватывающих скобок, PCRE
   требуется больше памяти для обработки рекурсии, чем обычно.
   Память выделяется при помощи функции pcre_malloc, и освобождается
   соответственно функцией pcre_free. Если память не может быть выделена,
   сохраняются данные только для первых 15 захватывающих скобок,
   так как нет способа выдать ошибку out-of-memory изнутри рекурсии.
  </p>

  <p class="para">
   <em>(?1)</em>, <em>(?2)</em> и так далее
   могут быть использованы для рекурсивных подмасок.
   Также возможно использовать именованные подмаски:
   <em>(?P&gt;name)</em> или <em>(?&amp;name)</em>.
  </p>
  <p class="para">
   Если синтаксис ссылки на рекурсивную подмаску (как по имени, так и по
   числовому индексу) используется вне скобок, к которым он относится, он
   отрабатывает аналогично подпрограмме в языке программирования.
   Возьмем более ранний пример, указывающий что шаблон
   <em>(sens|respons)e and \1ibility</em>
   соответствует &quot;sense and sensibility&quot; и &quot;response and responsibility&quot;,
   но не &quot;sense and responsibility&quot;. Если вместо этого использовать шаблон
   <em>(sens|respons)e and (?1)ibility</em>,
   он совпадет с &quot;sense and responsibility&quot; так же, как и с другими двумя
   строками. Однако, такие ссылки должны быть указаны после подмаски, на которую
   они ссылаются.
  </p>

  <p class="para">
   Максимальная строка обрабатываемой строки не должна превышать максимально
   доступного целого числа. Однако, так как для обработки подмасок
   и бесконечного повторения PCRE использует рекурсию, это означает, что
   размер обрабатываемых строк в некоторых шаблонах также может быть
   ограничен доступным размером стэка.
  </p>

 </div><hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="regexp.reference.comments.html">Комментарии</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="regexp.reference.performance.html">Производительность</a></div>
 <div class="up"><a href="reference.pcre.pattern.syntax.html">Описание синтаксиса Perl-совместимых регулярных выражений</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
